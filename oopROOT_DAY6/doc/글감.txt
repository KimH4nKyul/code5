```
String s2 = new String("abcd");
String s1 = "abcd";
```
String 클래스는 java 로 개발을 쉽게 할수 있게 한 대표 클래스중 하나입니다. new 생성자가 아니더라도 사람이 이해하기 쉬운 "(쌍따옴표) 기호를 사용할 수 있어 비즈니스로직에 필수인 데이터를 String 으로 쉽게 취급해 사용할 수 있게 해줍니다.

```
String s1 = "abcd";
String s2 = "abcd";

// s2 는 s1 에서 생성된 String 객체를 재사용합니다.
// true 		
System.out.println(s1.hashCode()==s2.hashCode());
```
실행시점 String은 객체입니다. 그리고 한번 생성된 String 객체의 내부 데이터는 변경할 수 없는 immutable(불변의)성질을 가지고 있습니다. 그래서 String Pool 이라는 메모리 영역에 String 을 저장하고 똑같은 형태의 String 이 필요할 때 재사용합니다.

```
int i = 1234;

String s = "" + i;

i = Integer.parseInt(s);
```
String 은 기본데이터형으로 변환할때 유용합니다. String 에서 int, long 로 변환이 쉽고 반대의 경우도 + 연산자를 통해 쉽게 변환할 수 있습니다.

```
String data1 = "abcd1111";
String[] data2 = new String[]{"abcd1", "abcd2"};
String[][] data3 = new String[]{{"row1","abcd1", "abcd2"},{"row2","abcd1", "abcd2"}};
```
String 은 비즈니스로직에 사용되는 데이터를 취급할 수 있는 가장 좋은 객체입니다. 하나의 데이터는 하나의 String 을 사용하고 나열되는 데이터는 String 배열 그리고 테이블 형태의 데이터는 String 배열을 2차원으로 선언해 사용합니다.

```
String[] data2 = new String[]{"abcd1", "abcd2"};

// 새로운 데이터를 추가할때 배열을 다시 생성해야함
data2 = new String[]{"abcd1", "abcd2", "abcd3"};

```
하지만 배열은 문제가 있습니다. 동적으로 데이터가 생성되는 업무에서는 정적인 배열을 사용할 수 없습니다. 그리고 삽입, 삭제등 배열에 필수인 기능은 제약이 있습니다.

```java
String[] data1 = new String[]{"abcd1", "abcd2"};

ArrayList<String> data2 = new ArrayList<String>();
data2.add("abcd1");
data2.add("abcd2");

```

```
/**
 * @author seuk
 * 
 *         공지사항 DAO
 *
 */
public class Comm001D {

	/**
	 * @param pageNo
	 * @return
	 * 
	 *         공지사항 리스트 조회
	 */
	List<Map<String, String>> comm00101() {

		Map<String, String> hm = new HashMap<String, String>();
		List<Map<String, String>> list = new ArrayList<Map<String, String>>();
		
		// 아직 SQL 관련된 모듈은 작업하지 못했음

		list.add(hm);

		return list;
	}
}

```
- 게시물 리스트를 SQL을 수행해 String 으로 구성된 컬랙션 객체에 담아 반환하는 메소드 입니다.  앞서 이야기 한것처럼 String 은 데이터를 취급할때 적절한 객체이고 String 이 테이블형태로 구성되었을때 List 와 Map 으로 구성된 컬랙션에 담는게 최선의 방벙입니다.
- 하지만 컬랙션 객체는 동적으로 생성된 객체를 보관하고 사용할때 필요하지만 컬랙션 객체의 근본적인 성능 문제와 
- 이번장은 컬렉션객체의 단점인 성능을 개선하고 장점인 유연함을 살린 Table 클래스를 을 만든다.
요청한 서비스에 대한 서브콘트롤러를 결정하거나 서브콘트롤러가 실행후 호출한 뷰를 결정할때 

```java
/**
 * @author seuk
 *
 */
public class Table {

	/**
	 * 
	 */
	private String[][] data = null;

	/**
	 * 
	 */
	private HashMap<String, BigDecimal> colsNameMap = null;

	/**
	 * @param cols
	 * @param data
	 * @throws Exception
	 */
	public Table_step01(String[] cols, String[][] data) throws Exception {

		if (data.length != cols.length) {
			throw new Exception();
		}

		this.data = data;

		for (int i = 0; i < cols.length; i++) {
			colsNameMap.put(cols[i], new BigDecimal(i));
		}
	}

	/**
	 * @param col
	 * @param row
	 * @return
	 */
	public String s(String col, int row) {

		int cos = colsNameMap.get(col).intValue();
		return data[cos][row];

	}

}

```
- Table 은 DB관점의 테이블과 동일한 자료구조를 가지고 있다. 2차원의 String 배열와 String 배열의 컬럼정보를 생성자로 가지고 있고 컬럼과 열의번호를 가지고 데이터를 가져오는 메소드를 제공한다.
- 그런데 Table 은 문제가 있다. 테이블을 생성한후 내부 자료를 수정하거나 새로운 데이터를 입력할 수 없는 단점이 있기 때문이다.
- 그래서 생성자로 전달된 데이터는 보호함과 동시에 데이터를 관리할 수 있도록 개선한다.
```java

/**
 * @author seuk
 *
 */
public class Table {

	/**
	 * 
	 */
	private String[][] data = null;

	/**
	 * 
	 */
	private HashMap<String, BigDecimal> colsNameMap = null;

	/**
	 * [1] 추가데이터를 관리하는 컬랙션 객체
	 */
	private HashMap<String, String> addData = null;

	/**
	 * [2] 추가데이터가 지정한 최대 row 값이 maxLength
	 */
	private int maxLength = -1;

	/**
	 * @param cols
	 * @param data
	 */
	public Table(String[] cols, String[][] data) {

		if (cols == null) {
			throw new RuntimeException();
		}

		if (data == null) {
			throw new RuntimeException();
		}

		if (data.length != cols.length) {
			throw new RuntimeException();
		}

		this.data = data;
		this.colsNameMap = new HashMap<String, BigDecimal>();
		this.maxLength = data.length;

		for (int i = 0; i < cols.length; i++) {
			this.colsNameMap.put(cols[i], new BigDecimal(i));
		}
	}

	/**
	 * 
	 */
	public Table() {
		this.data = new String[][] { {} };
		this.maxLength = 0;
		colsNameMap = new HashMap<String, BigDecimal>();
	}

	/**
	 * @return
	 */
	public int length() {
		if (maxLength == -1) {
			throw new RuntimeException();
		}
		return maxLength;
	}

	/**
	 * @param colName
	 * @param row
	 * @return
	 */
	public String getRowData(String colName, int row) {

		BigDecimal colB = colsNameMap.get(colName);
		if (colB == null) {
			throw new RuntimeException();
		}

		int col = colB.intValue();

		if (data.length < col) {
			return "";
		}

		if (data[col].length < row) {
			return "";
		}

		String thisData = data[col][row];
		if (thisData == null) {
			return "";
		}
		return thisData;

	}

	/**
	 * @param colName
	 * @param row
	 * @return
	 */
	public String getData(String colName, int row) {
		return s(colName, row);
	}

	/**
	 * @param col
	 * @param row
	 * @return
	 * 
	 *         [3] 개발자가 조정한 데이터를 우선 리턴하고 업으면 생성자의 데이터를 린턴한다.
	 */
	public String s(String colName, int row) {

		BigDecimal colB = colsNameMap.get(colName);
		if (colB == null) {
			throw new RuntimeException();
		}

		if (addData == null) {
			return getRowData(colName, row);
		}

		String key = colName + "_" + row;
		String data = addData.get(key);
		if (data != null) {
			return data;
		}

		return getRowData(colName, row);

	}

	/**
	 * @param colName
	 * @param row
	 * @param data
	 * 
	 *                [4] 컬랙션 객체의 장점을 살려 추가데이터는 Map 형태로 저장한다.
	 */
	public void addData(String colName, int row, String data) {

		BigDecimal colB = colsNameMap.get(colName);
		if (colB == null) {
			colsNameMap.put(colName, new BigDecimal(colsNameMap.size() + 1));
		}

		String key = colName + "_" + row;

		if (addData == null) {
			addData = new HashMap<String, String>();
		}
		addData.put(key, data);

		if (row > maxLength - 1) {
			maxLength = row;
		}
	}

	/**
	 * @param row
	 * @return
	 */
	public Box getBox(int row) {

		Box box = new BoxLocal();
		Iterator<String> iterator = colsNameMap.keySet().iterator();
		while (iterator.hasNext()) {
			String colName = iterator.next();
			String data = s(colName, row);
			box.put(colName, data);
		}

		return box;

	}

}

```
- 뭔가 부족했던 Table 클래스의 기능을 개선했습니다.  먼저 생성된 Table 을 사용할때 추가되는 데이터를 저장할 수 있는
- 