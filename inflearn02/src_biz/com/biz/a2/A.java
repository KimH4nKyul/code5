package com.biz.a2;

import com.code5.fw.data.InitYaml;

/**
 * @author zero
 *
 *         인터페이스와 구현클래스가 1:1 관계일때는 인터페이스를 제거합니다.
 */
class A {

	void execute() {

		// 결합도
		// 2개 이상의 모듈간의 관계를 측정하는 척도

		// 내용결합 : 코드를 사용 기능이 교환
		// 공통결합
		// 외부결합
		// 제어결합
		// 스템프결합 : 구조체로 통해 기능이 교환, 인터페이스/추상화클래스
		// 자료결합 : 데이터를 통해 기능이 교환

		// 자료결합은 가장높은 개발비용 가장낮은 결합도
		// 내용결합은 가장낮은 개발비용 가장높은 결합도

		// 가장낮은 결합도가 좋지만 가장낮은 개발비용을 사용하는 것도 좋음

		// 낮은 결합도를 위해
		// 구현클래스와 인터페이스를 1:1 관계로 구성

		// 인터페이스 : 필요한 기능을 추상화 한 틀
		// 인터페이스 구현 : 틀에 맞춰 기능을 구현

		// B 틀
		// BImpl 틀에 맞춰 구현된 코드
		B 객체 = new BImpl();

		객체.문제가있음();

		객체.잘만들어짐();
		객체.잘만들어짐(0);

		객체.실행시점에따라다름();

		// 인터페이스를 사용한다고
		// 내용결합에 있던 문제가 없어지는 건 아님

		// 오히려 인터페이스 때문에 코드 복잡도가 높아지고
		// 정보은닉을 하지 못함. (public, protected)

	}

}

interface B {

	public void 문제가있음();

	public int 잘만들어짐();

	public int 잘만들어짐(int i);

	public void 실행시점에따라다름();
}

class BImpl implements B {

	public void 문제가있음() {
		// 문제1 해결 : 기능의 수정, 결함제거/리펙토링
	}

	private int 잘만들어진기능에서사용하는데이터 = 0;

	public int 잘만들어짐() {
		return 잘만들어진기능에서사용하는데이터++;
	}

	public int 잘만들어짐(int i) {

		// 문제2 해결 : 기능의 추가, 오버로딩/새로운메소드

		잘만들어진기능에서사용하는데이터 = i;
		잘만들어진기능에서사용하는데이터++;
		return 잘만들어진기능에서사용하는데이터;

	}

	public void 실행시점에따라다름() {

		// 문제3 해결 : 기능의 교체, 실행시점에 기능이 결정

		boolean isDev = InitYaml.get().is("isDev");
		if (isDev) {
			// 가상의 기능
			// stub : 다른 모듈의 테스트를 위해 만들어진 가상의 기능
			return;
		}

		// 실제 기능
	}

}
