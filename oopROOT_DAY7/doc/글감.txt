DBMS(이하 DB)는 비즈니스로직을 구현할때 필수적으로 사용하는 솔류션입니다. 여러명이 동시에 똑같은 업무를 이용하더라도 일관된 데이터를 보여줄 수 있고 시스템에 장애가 발생하더라도 데이터를 회복할 수 있는 기능을 제공하기 때문입니다.
웹서비스를 구성할때 최소한 WAS 와 DBMS 2개의 서버를 사용하고 WAS 는 비즈니스로직을 처리하고 DBMS 는 비즈니스로직에 필요한 데이터를 관리하는 역할을 배정합니다.
트랜젝션은 DBMS 에서 데이터를 관리하기 위한 실행단위입니다. 데이터는 입력/수정/삭제/조회 4가지 기능으로 관리되고 여러개의 입력/수정/삭제/조회 요청을 하나의 트랜젝션으로 묶어 데이터의 일관성을 보장합니다.
DBMS는 데이터의 일관성,무결성을 위해 복잡한 트랜젝션 처리를 합니다. 병렬또는 병행으로 실행되는 트랜잭션의 데이터를 세그먼트과 블럭 단위로 관리하고 MVCC 나 2PL 등의 기법을 사용해 트랜젝션의 직렬성을 보장합니다.
DBMS는 DBMS 솔류션의 가격만큼 가치가 있지만 데이터를 관리하는 과정을 쉽게 이해할 수 없습니다.

하지만 프레임웍은 이런 DBMS의 복잡함을 단순하게 해주고 쉽게 사용할 수 있게 해줍니다. DBMS 종류가 어떠하든, Connection 객체의 생성이 어떠하든 개발자는 DBMS 의 기능만 이용하면 됩니다. 

먼저 SqlRunner 클래스를 소개합니다. SqlRunner 클래스는 인터페이스로만 구성되어 있습니다. 개발자는 SqlRunner 가 실제 어떻게 동작하는지는 관심 없습니다. 
인터페이스에서 정의한대로만 잘 구현되면 됩니다. 2개의 메소드만 선언합니다.
getData()
executeSql()
그런데 인터페이스는 구현클래스가 있어야지 객체로 생성될 수 있습니다. 따라서 인터페이스를 가상으로 구현한 구현클래스를 미리 마련해 둡니다. 이후 SqlRunner 를 실제로 구현한 클래스로 교체합니다.   


추상화 클래스인 TransactionContext 를 준비합니다. TransactionContext 는 JDBC 에서 제공하는 Connection 객체를 멤버객체로 가지고 있습니다. 
트랜젝션제어에 필요한 commit, rollback 을 프레임웍에서 제어하기 위한 코드가 기록됩니다.


마지막으로    TransactionContext 를 AOP 횡단 관점으로 등록합니다. 쉽게 이야기 하면 개발자는 DB의 접속, SQL 수행, commit 이나 rollback 을 신경 쓰지 않게 한다는 것입니다.
TransactionContext 를 마스터콘트롤러에 적용하겠습니다.
commit 은 서브콘톨러가 오류없이 수행되었을때 실행하고 rollback 은 서브콘트롤의 오류가 발생할때 호출합니다.
비즈니스로직을 구현할대 정상수행 또는 수행중오류 2가지 경우만 있다고 정의합니다.



commit 또는 rollback  
  